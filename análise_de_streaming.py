# -*- coding: utf-8 -*-
"""Análise de Streaming (Versão Final)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cWqgjBs-dHTg6OhfgLlHd7A1E2c7Ae2G
"""

# %% [markdown]
# # Projeto de Análise de Streaming de Música - Fase 2
# **Autor:** Edinaldo Morais de Andrade Junior
# **Objetivo:** Análise exploratória, visualização de dados e relatório de insights estratégicos.

# %%
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats

# --- CONFIGURAÇÕES GLOBAIS ---
sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (12, 6)
plt.rcParams['font.size'] = 10

# Paleta de Cores Profissional/Pastel
CORES_PALETA = ['#FF9999', '#66B2FF', '#99FF99', '#FFCC99', '#c2c2f0', '#ffb3e6']
sns.set_palette(CORES_PALETA)

# --- FUNÇÕES AUXILIARES ---
def plotar_linhas_referencia(dados, coluna, ax):
    """Adiciona linhas verticais de Média, Mediana e Moda a um eixo."""
    media = dados[coluna].mean()
    mediana = dados[coluna].median()
    try:
        moda = dados[coluna].mode()[0]
    except:
        moda = mediana # Fallback

    ax.axvline(media, color='red', linestyle='--', linewidth=2, label=f'Média: {media:.1f}')
    ax.axvline(mediana, color='green', linestyle='-', linewidth=2, label=f'Mediana: {mediana:.1f}')
    ax.axvline(moda, color='blue', linestyle=':', linewidth=2, label=f'Moda: {moda:.1f}')
    ax.legend()

def rotular_barras_percentual(ax, feature_series):
    """Adiciona rótulos de porcentagem acima das barras."""
    total = len(feature_series)
    for p in ax.patches:
        height = p.get_height()
        if pd.notna(height):
            ax.text(p.get_x() + p.get_width() / 2.,
                    height + (height * 0.01),
                    f'{height/total:.1%}',
                    ha="center", fontsize=10, color='black', fontweight='bold')

# %% [markdown]
# ## PASSO 0: Carregamento e Validação

# %%
try:
    df = pd.read_csv('dados_streaming_musica.csv')
    print("Arquivo carregado com sucesso!")
    print(f"Dimensões do Dataset: {df.shape}")
except FileNotFoundError:
    print("ERRO: O arquivo 'dados_streaming_musica.csv' não foi encontrado.")
    # Dados dummy para execução de teste
    data = {
        'id_usuario': range(100),
        'idade': np.random.randint(18, 60, 100),
        'genero': np.random.choice(['M', 'F'], 100),
        'plano': np.random.choice(['Premium', 'Gratuito', 'Familiar'], 100),
        'tempo_uso_diario_min': np.random.normal(150, 40, 100),
        'musicas_ouvidas_dia': np.random.normal(30, 10, 100),
        'genero_favorito': np.random.choice(['Rock', 'Pop', 'Sertanejo', 'Eletrônica'], 100),
        'dispositivo': np.random.choice(['Smartphone', 'Desktop', 'Tablet'], 100),
        'regiao': np.random.choice(['Sul', 'Sudeste', 'Norte', 'Nordeste'], 100),
        'avaliacao_app': np.random.uniform(1, 5, 100),
        'pula_musicas_dia': np.random.randint(0, 20, 100)
    }
    df = pd.DataFrame(data)

print("\n--- Informações do DataFrame ---")
df.info()
print("\n--- Primeiras 5 linhas ---")
print(df.head())

# %% [markdown]
# ## PASSO 1: Análise de Perfil (Demografia)

# %%
# 1.1 Idade
plt.figure(figsize=(10, 6))
ax = sns.histplot(data=df, x='idade', kde=True, color=CORES_PALETA[1], bins=20)
plotar_linhas_referencia(df, 'idade', ax)
plt.title('Distribuição de Idade dos Usuários')
plt.xlabel('Idade')
plt.show()

# 1.2 Gênero
plt.figure(figsize=(8, 6))
n_generos = df['genero'].nunique()
ax = sns.countplot(data=df, x='genero', hue='genero', palette=CORES_PALETA[:n_generos], legend=False)
rotular_barras_percentual(ax, df['genero'])
plt.title('Distribuição por Gênero')
plt.show()

# 1.3 Região
plt.figure(figsize=(10, 6))
contagem_regiao = df['regiao'].value_counts()
plt.pie(contagem_regiao, labels=contagem_regiao.index, autopct='%1.1f%%', colors=CORES_PALETA, startangle=140)
plt.title('Distribuição de Usuários por Região')
plt.show()

# %% [markdown]
# ## PASSO 2: Análise de Comportamento de Uso

# %%
# 2.1 Tempo de Uso
print("\n--- Estatísticas Tempo de Uso ---")
print(df['tempo_uso_diario_min'].describe())

plt.figure(figsize=(10, 6))
ax = sns.histplot(data=df, x='tempo_uso_diario_min', kde=True, color=CORES_PALETA[0])
plotar_linhas_referencia(df, 'tempo_uso_diario_min', ax)
plt.title('Distribuição do Tempo de Uso Diário (min)')
plt.show()

# 2.2 Músicas Ouvidas (Histograma com Desvio Padrão + Boxplot)
media_musicas = df['musicas_ouvidas_dia'].mean()
std_musicas = df['musicas_ouvidas_dia'].std()

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

# Histograma
sns.histplot(data=df, x='musicas_ouvidas_dia', kde=True, ax=ax1, color=CORES_PALETA[2])
plotar_linhas_referencia(df, 'musicas_ouvidas_dia', ax1)
# Área do Desvio Padrão
ax1.axvspan(media_musicas - std_musicas, media_musicas + std_musicas, color='gray', alpha=0.2, label='Desvio Padrão')
ax1.legend()
ax1.set_title('Músicas Ouvidas (com Faixa de Desvio Padrão)')

# Boxplot
sns.boxplot(data=df, x='musicas_ouvidas_dia', ax=ax2, color=CORES_PALETA[2])
ax2.set_title('Boxplot: Músicas Ouvidas por Dia')
plt.show()

# 2.3 Preferências
moda_genero = df['genero_favorito'].mode()[0]
ordem_genero = df['genero_favorito'].value_counts().index
paleta_generos = sns.color_palette('pastel', len(ordem_genero))

plt.figure(figsize=(10, 6))
sns.countplot(data=df, y='genero_favorito', hue='genero_favorito', order=ordem_genero, palette=paleta_generos, legend=False)
plt.title(f'Gêneros Musicais Favoritos (Mais popular: {moda_genero})')
plt.show()

# 2.4 Avaliação
kpi_satisfacao = (df['avaliacao_app'] >= 4.0).mean() * 100
plt.figure(figsize=(10, 6))
ax = sns.histplot(data=df, x='avaliacao_app', kde=True, bins=10, color=CORES_PALETA[3])
plotar_linhas_referencia(df, 'avaliacao_app', ax)
plt.title(f'Avaliações do App (Satisfação: {kpi_satisfacao:.1f}%)')
plt.show()

# 2.5 Correlação
plt.figure(figsize=(10, 8))
sns.scatterplot(data=df, x='tempo_uso_diario_min', y='musicas_ouvidas_dia', hue='plano', alpha=0.7, s=100, palette='deep')
plt.title('Correlação: Tempo de Uso vs. Músicas Ouvidas')
plt.show()

# %% [markdown]
# ## PASSO 3: Análise por Segmentos

# %%
# 3.1 Comparação por Plano
fig, ax = plt.subplots(1, 3, figsize=(18, 6))
planos_unicos = df['plano'].dropna().unique()
paleta_planos = dict(zip(planos_unicos, CORES_PALETA[:len(planos_unicos)]))

sns.barplot(data=df, x='plano', y='tempo_uso_diario_min', hue='plano', ax=ax[0], palette=paleta_planos, errorbar=None, legend=False)
ax[0].set_title('Tempo Médio por Plano')

sns.histplot(data=df, x='tempo_uso_diario_min', hue='plano', element="step", ax=ax[1], palette='deep')
ax[1].set_title('Distribuição de Tempo por Plano')

sns.boxplot(data=df, x='plano', y='tempo_uso_diario_min', hue='plano', ax=ax[2], palette=paleta_planos, legend=False)
ax[2].set_title('Boxplot de Tempo por Plano')
plt.show()

# 3.2 Comparação por Dispositivo
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))
disp_unicos = df['dispositivo'].dropna().unique()
paleta_disp = dict(zip(disp_unicos, CORES_PALETA[:len(disp_unicos)]))

sns.barplot(data=df, x='dispositivo', y='tempo_uso_diario_min', hue='dispositivo', ax=ax1, palette=paleta_disp, errorbar=None, legend=False)
ax1.set_title('Tempo de Uso Médio por Dispositivo')

sns.barplot(data=df, x='dispositivo', y='avaliacao_app', hue='dispositivo', ax=ax2, palette='magma', errorbar=None, legend=False)
ax2.set_title('Avaliação Média por Dispositivo')
ax2.set_ylim(0, 5)
plt.show()

# 3.3 Demografia por Gosto Musical
plt.figure(figsize=(10, 6))
media_idade_genero = df.groupby('genero_favorito')['idade'].mean().sort_values().reset_index()
paleta_blues = sns.color_palette('Blues_d', len(media_idade_genero))

sns.barplot(data=media_idade_genero, x='genero_favorito', y='idade', hue='genero_favorito', palette=paleta_blues, legend=False)
plt.title('Idade Média por Gênero Musical')
plt.xticks(rotation=45)
plt.show()

# %% [markdown]
# ## PASSO 4: Relatório Final de Insights

# %%
# Cálculos Finais
perfil_idade_media = df['idade'].mean()
perfil_regiao_top = df['regiao'].mode()[0]
perfil_genero_top = df['genero'].mode()[0]
tempo_medio_geral = df['tempo_uso_diario_min'].mean()
tempo_mediano_geral = df['tempo_uso_diario_min'].median()
musicas_media_geral = df['musicas_ouvidas_dia'].mean()
genero_musical_top = df['genero_favorito'].mode()[0]
uso_premium = df[df['plano'] == 'Premium']['tempo_uso_diario_min'].mean()
uso_gratuito = df[df['plano'] == 'Gratuito']['tempo_uso_diario_min'].mean()
pulos_premium = df[df['plano'] == 'Premium']['pula_musicas_dia'].mean()
pulos_gratuito = df[df['plano'] == 'Gratuito']['pula_musicas_dia'].mean()
disp_agrupado = df.groupby('dispositivo')['avaliacao_app'].mean()
pior_dispositivo = disp_agrupado.idxmin()
nota_pior_disp = disp_agrupado.min()
dispositivo_top = df['dispositivo'].mode()[0]

print("=" * 60)
print("RELATÓRIO FINAL DE INSIGHTS ESTRATÉGICOS")
print("=" * 60)

relatorio = f"""
1. PERFIL GERAL DO USUÁRIO
   - Idade Média: {perfil_idade_media:.0f} anos.
   - Gênero Predominante: {perfil_genero_top}.
   - Região Predominante: {perfil_regiao_top}.

2. COMPORTAMENTO DE USO TÍPICO (Geral)
   - Tempo de Uso: O usuário típico passa cerca de {tempo_medio_geral:.0f} min/dia.
     (A mediana de {tempo_mediano_geral:.0f} min confirma um comportamento padrão e estável).
   - Consumo Musical: Em média, são ouvidas {musicas_media_geral:.0f} músicas por dia.

3. COMPARAÇÃO: PREMIUM VS. GRATUITOS
   - Tempo de Uso: Premium ({uso_premium:.0f} min) vs Gratuito ({uso_gratuito:.0f} min).
     > O plano Premium retém o usuário por mais tempo.
   - Pular Músicas: Premium ({pulos_premium:.1f} pulos) vs Gratuito ({pulos_gratuito:.1f} pulos).
     > Usuários gratuitos pulam mais, indicando fricção na experiência.

4. POPULARIDADE: PREFERÊNCIAS E PLATAFORMAS
   - Gênero Musical Mais Popular: {genero_musical_top}.
   - Dispositivo Mais Usado: {dispositivo_top}.

5. RECOMENDAÇÕES DE NEGÓCIO E ALERTA TÉCNICO
   (A) Engenharia (Crítico): O dispositivo {pior_dispositivo} tem a pior nota ({nota_pior_disp:.2f}/5.0).
       Ação: Investigar bugs específicos nesta plataforma imediatamente.
   (B) Marketing (Upsell): Campanha "Pare de Pular" focada nos usuários Gratuitos.
   (C) Conteúdo: Playlists regionais para o {perfil_regiao_top} focadas em {genero_musical_top}.
"""
print(relatorio)
print("=" * 60)